// Copyright 2025 Red Hat Inc.
// SPDX-License-Identifier: Apache-2.0

package main

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"slices"
	"strings"
	"time"

	"github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/plumbing"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
	"github.com/thekad/magic-ansible/pkg/ansible"
	"github.com/thekad/magic-ansible/pkg/api"
	tpl "github.com/thekad/magic-ansible/pkg/template"
)

const MMV1_REPO string = "https://github.com/GoogleCloudPlatform/magic-modules"

type argList []string

func (al *argList) String() string {
	return fmt.Sprint(*al)
}

func (al *argList) Set(value string) error {
	for _, a := range strings.Split(value, ",") {
		*al = append(*al, strings.ToLower(strings.TrimSpace(a)))
	}
	return nil
}

var gitDir string
var gitRev string
var gitPull bool
var products argList
var resources argList
var output string
var overrides string
var templates string
var dontGenerateCode bool
var dontGenerateTests bool
var overwrite bool
var gitURL string

func init() {
	flag.StringVar(&gitURL, "git-url", MMV1_REPO, "git repository to clone")
	flag.StringVar(&gitDir, "git-dir", "magic-modules", "path to clone magic modules repo")
	flag.StringVar(&gitRev, "git-rev", "main", "git revision to checkout")
	flag.BoolVar(&gitPull, "git-pull", false, "git pull before checkout")
	flag.StringVar(&output, "output", "output", "path to write autogenerated files")
	flag.StringVar(&overrides, "overrides", "overrides", "path to override files")
	flag.StringVar(&templates, "templates", "templates", "path to template files")
	flag.Var(&products, "products", "comma-separated list of products to generate")
	flag.Var(&resources, "resources", "comma-separated list of resources to generate")
	flag.BoolVar(&dontGenerateCode, "no-code", false, "skip code generation")
	flag.BoolVar(&dontGenerateTests, "no-tests", false, "skip test generation")
	flag.BoolVar(&overwrite, "overwrite", false, "overwrite existing files")

	// configure logging
	logLevelStr := os.Getenv("LOG_LEVEL")

	if logLevelStr == "" {
		logLevelStr = "info"
	}

	log.Logger = log.Output(zerolog.ConsoleWriter{
		Out:        os.Stderr,
		TimeFormat: time.RFC3339,
		// NoColor:    true,
	})

	// Map the string to a zerolog level.
	switch strings.ToLower(logLevelStr) {
	case "trace":
		zerolog.SetGlobalLevel(zerolog.TraceLevel)
	case "debug":
		zerolog.SetGlobalLevel(zerolog.DebugLevel)
	case "info":
		zerolog.SetGlobalLevel(zerolog.InfoLevel)
	case "warn":
		zerolog.SetGlobalLevel(zerolog.WarnLevel)
	case "error":
		zerolog.SetGlobalLevel(zerolog.ErrorLevel)
	case "fatal":
		zerolog.SetGlobalLevel(zerolog.FatalLevel)
	case "panic":
		zerolog.SetGlobalLevel(zerolog.FatalLevel)
	default:
		// Set to a safe default if the value is not recognized.
		zerolog.SetGlobalLevel(zerolog.InfoLevel)
		log.Warn().Msgf("Unrecognized LOG_LEVEL '%s', defaulting to 'info'", logLevelStr)
	}

	log.Info().Msgf("Log level set to %s", zerolog.GlobalLevel())
}

// doGitClone clones the git repository to the given path
func doGitClone(path string, ref string, pull bool) error {
	log.Info().Msgf("git-clone %s to %s\n", gitURL, path)
	_, err := git.PlainClone(path, false, &git.CloneOptions{
		URL:      gitURL,
		Progress: os.Stdout,
	})
	if err != nil {
		log.Warn().Msgf("git-clone: %s", err)
	}

	repo, err := git.PlainOpen(path)
	if err != nil {
		return fmt.Errorf("can't open git dir %s: %v", path, err)
	}

	worktree, err := repo.Worktree()
	if err != nil {
		return fmt.Errorf("can't open worktree: %v", err)
	}

	if pull {
		if err := worktree.Pull(&git.PullOptions{RemoteName: "origin"}); err != nil {
			return fmt.Errorf("can't pull from 'origin' remote: %v", err)
		}
		log.Info().Msg("git-pull: success")
	}

	h, err := repo.ResolveRevision(plumbing.Revision(ref))
	if err != nil {
		return fmt.Errorf("can't resolve revision %s: :%v", ref, err)
	}

	coOpts := git.CheckoutOptions{
		Hash:  *h,
		Force: true,
	}
	if err := worktree.Checkout(&coOpts); err != nil {
		return fmt.Errorf("can't checkout worktree: %v", err)
	}

	log.Info().Msgf("git-checkout %s: success", ref)

	return nil
}

// doFindProducts finds the matching product.yaml files in the given git directory
func doFindProducts(gitDir string, names []string, templateDir string, overridesDir string) ([]*api.Product, error) {
	products := []*api.Product{}

	allFiles, err := filepath.Glob(fmt.Sprintf("%s/mmv1/products/**/product.yaml", gitDir))
	if err != nil {
		return nil, err
	}

	for _, pf := range allFiles {
		pName := filepath.Base(filepath.Dir(pf))
		if len(names) == 0 || slices.Contains(names, pName) {
			p := api.NewProduct(pf, templateDir, overridesDir)
			products = append(products, p)
		}
	}

	return products, nil
}

// doPopulateResourcesByProduct populates the resources for the given product
func doPopulateResourcesByProduct(gitDir string, product *api.Product, names []string) error {
	allFiles, _ := filepath.Glob(fmt.Sprintf("%s/mmv1/products/%s/*.yaml", gitDir, product.Name))
	for _, rf := range allFiles {
		if filepath.Base(rf) == "product.yaml" {
			continue
		}
		rName := strings.TrimSuffix(filepath.Base(rf), filepath.Ext(filepath.Base(rf)))
		if len(names) == 0 || slices.Contains(names, strings.ToLower(rName)) {
			r := api.NewResource(rf, product, product.TemplateDir, product.OverridesDir)
			product.Resources = append(product.Resources, r)
		}
	}

	return nil
}

func main() {
	flag.Parse()
	absDir, _ := filepath.Abs(gitDir)
	templateDir, _ := filepath.Abs(templates)
	overrideDir, _ := filepath.Abs(overrides)

	if err := doGitClone(absDir, gitRev, gitPull); err != nil {
		log.Fatal().Err(err).Msg("failed to clone git repository")
	}
	productsToGenerate, err := doFindProducts(absDir, products, templateDir, overrideDir)
	if err != nil {
		log.Fatal().Err(err).Msg("failed to find products")
	}
	log.Debug().Msgf("matching products: %v", productsToGenerate)

	log.Info().Msgf("template directory is %v", templateDir)

	templateData := tpl.NewTemplateData(templateDir, output, overwrite)
	log.Debug().Msgf("template data: %v", templateData)

	// build list of modules to generate
	modulesToGenerate := []*ansible.Module{}
	for _, p := range productsToGenerate {
		// populate resources for given products
		err := doPopulateResourcesByProduct(gitDir, p, resources)
		if err != nil {
			log.Fatal().Err(err).Msg("failed to populate resources for product")
		}
		log.Debug().Msgf("matching resources for %s: %v", p.Name, p.Resources)

		// unmarshal product structs
		err = p.Unmarshal()
		if err != nil {
			log.Fatal().Err(err).Msg("failed to unmarshal product")
		}

		for _, r := range p.Resources {
			// unmarshal resource structs
			err := r.Unmarshal()
			if err != nil {
				log.Fatal().Err(err).Msg("failed to unmarshal resource")
			}

			// generate module struct
			module := ansible.NewFromResource(r)
			modulesToGenerate = append(modulesToGenerate, module)
		}
	}
	// generate modules

	for _, m := range modulesToGenerate {
		// generate code for resources
		if !dontGenerateCode {
			log.Info().Msgf("generating code for ansible module: %s", m)
			err := templateData.GenerateCode(m)
			if err != nil {
				log.Fatal().Err(err).Msg("failed to generate code for ansible module")
			}
		}
		// generate tests for resources
		if !dontGenerateTests {
			log.Info().Msgf("generating tests for ansible module: %s", m)
			err := templateData.GenerateTests(m)
			if err != nil {
				log.Fatal().Err(err).Msg("failed to generate tests for ansible module")
			}
		}
	}
}
