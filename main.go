// Copyright 2025 Red Hat Inc.
// SPDX-License-Identifier: Apache-2.0

package main

import (
	"flag"
	"fmt"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"slices"
	"strings"
	"time"

	mmv1product "github.com/GoogleCloudPlatform/magic-modules/mmv1/api/product"
	"github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/plumbing"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
	"github.com/thekad/magic-ansible/pkg/ansible"
	"github.com/thekad/magic-ansible/pkg/api"
	tpl "github.com/thekad/magic-ansible/pkg/template"
)

const MMV1_REPO string = "https://github.com/GoogleCloudPlatform/magic-modules"
const MIN_VERSION string = "beta"

type argList []string

func (al *argList) String() string {
	return fmt.Sprint(*al)
}

func (al *argList) Set(value string) error {
	for _, a := range strings.Split(value, ",") {
		*al = append(*al, strings.ToLower(strings.TrimSpace(a)))
	}
	return nil
}

var gitDir string
var gitRev string
var gitPull bool
var products argList
var resources argList
var output string
var overrides string
var templates string
var dontGenerateCode bool
var dontGenerateTests bool
var overwrite bool
var gitURL string
var minVersion string
var dontFormatFiles bool

func init() {
	flag.StringVar(&gitURL, "git-url", MMV1_REPO, "git repository to clone")
	flag.StringVar(&gitDir, "git-dir", "magic-modules", "path to clone magic modules repo")
	flag.StringVar(&gitRev, "git-rev", "main", "git revision to checkout")
	flag.BoolVar(&gitPull, "git-pull", false, "git pull before checkout")
	flag.StringVar(&output, "output", "output", "path to write autogenerated files")
	flag.StringVar(&overrides, "overrides", "overrides", "path to override files")
	flag.StringVar(&templates, "templates", "templates", "path to template files")
	flag.Var(&products, "products", "comma-separated list of products to generate")
	flag.Var(&resources, "resources", "comma-separated list of resources to generate")
	flag.BoolVar(&dontGenerateCode, "no-code", false, "skip code generation")
	flag.BoolVar(&dontGenerateTests, "no-tests", false, "skip test generation")
	flag.BoolVar(&dontFormatFiles, "no-format", false, "skip formatting files (i.e. black/yamlfmt)")
	flag.BoolVar(&overwrite, "overwrite", false, "overwrite existing files")
	flag.StringVar(&minVersion, "min-version", MIN_VERSION, "minimum version to generate")

	// configure logging
	logLevelStr := os.Getenv("LOG_LEVEL")

	if logLevelStr == "" {
		logLevelStr = "info"
	}

	log.Logger = log.Output(zerolog.ConsoleWriter{
		Out:        os.Stderr,
		TimeFormat: time.RFC3339,
		// NoColor:    true,
	})

	// Map the string to a zerolog level.
	switch strings.ToLower(logLevelStr) {
	case "trace":
		zerolog.SetGlobalLevel(zerolog.TraceLevel)
	case "debug":
		zerolog.SetGlobalLevel(zerolog.DebugLevel)
	case "info":
		zerolog.SetGlobalLevel(zerolog.InfoLevel)
	case "warn":
		zerolog.SetGlobalLevel(zerolog.WarnLevel)
	case "error":
		zerolog.SetGlobalLevel(zerolog.ErrorLevel)
	case "fatal":
		zerolog.SetGlobalLevel(zerolog.FatalLevel)
	case "panic":
		zerolog.SetGlobalLevel(zerolog.FatalLevel)
	default:
		// Set to a safe default if the value is not recognized.
		zerolog.SetGlobalLevel(zerolog.InfoLevel)
		log.Warn().Msgf("Unrecognized LOG_LEVEL '%s', defaulting to 'info'", logLevelStr)
	}

	log.Info().Msgf("Log level set to %s", zerolog.GlobalLevel())
}

// doGitClone clones the git repository to the given path
func doGitClone(path string, ref string, pull bool) error {
	log.Info().Msgf("git-clone %s to %s\n", gitURL, path)
	_, err := git.PlainClone(path, false, &git.CloneOptions{
		URL:      gitURL,
		Progress: os.Stdout,
	})
	if err != nil {
		log.Warn().Msgf("git-clone: %s", err)
	}

	repo, err := git.PlainOpen(path)
	if err != nil {
		return fmt.Errorf("can't open git dir %s: %v", path, err)
	}

	worktree, err := repo.Worktree()
	if err != nil {
		return fmt.Errorf("can't open worktree: %v", err)
	}

	if pull {
		if err := worktree.Pull(&git.PullOptions{RemoteName: "origin"}); err != nil {
			return fmt.Errorf("can't pull from 'origin' remote: %v", err)
		}
		log.Info().Msg("git-pull: success")
	}

	h, err := repo.ResolveRevision(plumbing.Revision(ref))
	if err != nil {
		return fmt.Errorf("can't resolve revision %s: :%v", ref, err)
	}

	coOpts := git.CheckoutOptions{
		Hash:  *h,
		Force: true,
	}
	if err := worktree.Checkout(&coOpts); err != nil {
		return fmt.Errorf("can't checkout worktree: %v", err)
	}

	log.Info().Msgf("git-checkout %s: success", ref)

	return nil
}

// doFindProducts finds the matching product.yaml files in the given git directory
func doFindProducts(gitDir string, names []string, templateDir string, overridesDir string) ([]*api.Product, error) {
	products := []*api.Product{}

	allFiles, err := filepath.Glob(fmt.Sprintf("%s/mmv1/products/**/product.yaml", gitDir))
	if err != nil {
		return nil, err
	}

	for _, pf := range allFiles {
		pName := filepath.Base(filepath.Dir(pf))
		if len(names) == 0 || slices.Contains(names, pName) {
			p := api.NewProduct(pf, templateDir, overridesDir)
			products = append(products, p)
		}
	}

	return products, nil
}

// doPopulateResourcesByProduct populates the resources for the given product
func doPopulateResourcesByProduct(gitDir string, product *api.Product, names []string) error {
	allFiles, _ := filepath.Glob(fmt.Sprintf("%s/mmv1/products/%s/*.yaml", gitDir, product.Name))
	for _, rf := range allFiles {
		if filepath.Base(rf) == "product.yaml" {
			continue
		}
		rName := strings.TrimSuffix(filepath.Base(rf), filepath.Ext(filepath.Base(rf)))
		if len(names) == 0 || slices.Contains(names, strings.ToLower(rName)) {
			r := api.NewResource(rf, product, product.TemplateDir, product.OverridesDir)
			if r == nil {
				continue
			}
			product.Resources = append(product.Resources, r)
		}
	}

	return nil
}

func main() {
	flag.Parse()
	absDir, _ := filepath.Abs(gitDir)
	templateDir, _ := filepath.Abs(templates)
	overrideDir, _ := filepath.Abs(overrides)

	if err := doGitClone(absDir, gitRev, gitPull); err != nil {
		log.Fatal().Err(err).Msg("failed to clone git repository")
	}
	productsToGenerate, err := doFindProducts(absDir, products, templateDir, overrideDir)
	if err != nil {
		log.Fatal().Err(err).Msg("failed to find products")
	}
	log.Debug().Msgf("matching products: %v", productsToGenerate)

	log.Info().Msgf("template directory is %v", templateDir)

	templateData := tpl.NewTemplateData(templateDir, output, overwrite)
	log.Debug().Msgf("template data: %v", templateData)

	// build list of modules to generate
	modulesToGenerate := []*ansible.Module{}
	minVersionObj := &mmv1product.Version{Name: minVersion}
	for _, p := range productsToGenerate {
		// populate resources for given products
		err := doPopulateResourcesByProduct(gitDir, p, resources)
		if err != nil {
			log.Fatal().Err(err).Msg("failed to populate resources for product")
		}
		log.Debug().Msgf("matching resources for %s: %v", p.Name, p.Resources)

		// unmarshal product structs
		err = p.Unmarshal()
		if err != nil {
			log.Fatal().Err(err).Msg("failed to unmarshal product")
		}

		for _, r := range p.Resources {
			// unmarshal resource structs
			err := r.Unmarshal()
			if err != nil {
				log.Fatal().Err(err).Msg("failed to unmarshal resource")
			}

			// check if the resource has a minimum version that is not supported by the product
			if r.Mmv1.NotInVersion(minVersionObj) {
				log.Warn().Msgf("resource %s.%s minimum version is %v, but %s is required", r.Parent.Name, r.Name, r.MinVersion(), minVersion)
				continue
			}

			// generate module struct
			module := ansible.NewFromResource(r)
			module.MinVersion = r.MinVersion()
			modulesToGenerate = append(modulesToGenerate, module)
		}
	}
	// generate modules

	for _, m := range modulesToGenerate {
		// generate code for resources
		if !dontGenerateCode {
			log.Info().Msgf("generating code for ansible module: %s", m)
			err := templateData.GenerateCode(m)
			if err != nil {
				log.Fatal().Err(err).Msg("failed to generate code for ansible module")
			}

			if !dontFormatFiles {
				filePath := path.Join(templateData.ModuleDirectory, fmt.Sprintf("%s.py", m.Name))
				log.Info().Msgf("formatting ansible module file: %s", filePath)
				err := formatFile(filePath, "black")
				if err != nil {
					log.Fatal().Err(err).Msg("failed to format code for ansible module")
				}
			}
		}
		// generate tests for resources
		if !dontGenerateTests {
			log.Info().Msgf("generating tests for ansible module: %s", m)
			err := templateData.GenerateTests(m)
			if err != nil {
				log.Fatal().Err(err).Msg("failed to generate tests for ansible module")
			}

			if !dontFormatFiles {
				dirPath := path.Join(templateData.IntegrationTestDirectory, m.Name)
				log.Info().Msgf("formatting integration tests for %s", m.Name)
				err := formatFile(dirPath, "yamlfmt")
				if err != nil {
					log.Fatal().Err(err).Msg("failed to format integration tests for ansible module")
				}
			}
		}
	}
}

func formatFile(filePath string, formatType string) error {
	log.Debug().Msgf("running %s on file: %s", formatType, filePath)
	switch formatType {
	case "black":
		if blackCmd := which("black"); blackCmd == "" {
			return fmt.Errorf("black not found in PATH")
		} else {
			return runCommand(fmt.Sprintf("%s --quiet %s", blackCmd, filePath), filepath.Dir(filePath))
		}
	case "yamlfmt":
		if yamlFmtCmd := which("yamlfmt"); yamlFmtCmd == "" {
			return fmt.Errorf("yamlfmt not found in PATH")
		} else {
			return runCommand("yamlfmt %s", filePath)
		}
	}
	return nil
}

// which searches for the given executable and returns the full path to it
// Returns empty string if the command is not found
func which(name string) string {
	if path, err := exec.LookPath(name); err == nil {
		return path
	}

	return ""
}

func runCommand(command string, dir string) error {
	parts := strings.Split(command, " ")
	cmd := exec.Command(parts[0], parts[1:]...)

	// Set working directory if provided
	if dir != "" {
		log.Debug().Msgf("changing directory to: %s", dir)
		cmd.Dir = dir
	}

	log.Debug().Msgf("running command: %s", command)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	return cmd.Run()
}
